#include "SceneFootsteps.h"
#include "SceneMain.h"
#include <AK/SoundEngine/Common/AkSoundEngine.h>		// Sound engine
#include "../WwiseProject/GeneratedSoundBanks/Wwise_IDs.h"	// IDs generated by Wwise
#include "WwiseWrapper.h"
#include "Helpers.h"
#include <string>
#include "Platform.h"
#include "PlatformCocos.h"

//#define  LOG_TAG    "SceneFootsteps"
#define  LOG_TAG    __FILE__

template <typename T> std::string tostr(const T& t) { std::ostringstream os; os << t; return os.str(); }

//Our game object ID.  Completely arbitrary.
#define GAME_OBJECT_HUMAN 10
#define HANGAR_TRANSITION_ZONE 25.f
#define HANGAR_SIZE 70
#define BUFFER_ZONE 20
#define RUN_SPEED 5.0f					
#define DIST_TO_SPEED (10/RUN_SPEED)	//The RTPC for speed is between 0 and 10.
#define WALK_PERIOD 30


struct SurfaceInfo
{
    SurfaceInfo(const char* in_szName)
	: strBankFile(BuildBankFileName(in_szName))
	, idSwitch(AK::SoundEngine::GetIDFromString(in_szName))
    {
    }
    const std::string strBankFile;
    const AkUniqueID idSwitch;

private:
    SurfaceInfo & operator=(const SurfaceInfo & in_other);

    static std::string BuildBankFileName(const char* in_szName)
    {
	std::string strBankFile(in_szName);
	strBankFile.append(".bnk");
	return strBankFile;
    }
};

static const SurfaceInfo k_surfaces[] =
{
    SurfaceInfo("Dirt"),
    SurfaceInfo("Wood"),
    SurfaceInfo("Metal"),
    SurfaceInfo("Gravel"),
};

#define DEMOFOOTSTEPS_SURFACE_COUNT	IntegrationDemoHelpers::AK_ARRAYSIZE( k_surfaces )

USING_NS_CC;

SceneFootsteps::SceneFootsteps()
    : SceneBase("Footsteps with multiple variables",
	"This demo shows various ways to deal with footsteps in "
	"Wwise.  It also shows environmental effects usage.\n\n"
	"The screen is divided in 4 surfaces, which correspond "
	"to the Surface switch.  In the middle of the screen, "
	"where all 4 surfaces meet, there is a hangar.  When "
	"entering this zone, the Hangar environmental effect "
	"becomes active.\n\n"
	"To test the footsteps, move the 'o' around with "
	"the <<DIRECTIONAL_TYPE>> or with the right stick. "
	"The displacement of the stick drives the Footstep_Speed RTPC. "
	"You can change the weight with <<UG_BUTTON3>> and <<UG_BUTTON4>> "
	"which drives the Footstep_Weight RTPC."
#if defined( _DEMOFOOTSTEPS_DYNAMIC_BANK_LOADING )
	"\n\nIf you connect the Wwise Profiler, you will also see "
	"that banks are loaded dynamically in this demo."
#endif // defined( _DEMOFOOTSTEPS_DYNAMIC_BANK_LOADING )
	,SceneMain::createScene)
,m_label(NULL)
//,m_labelPos(NULL)
{
    m_weight = 25;
    m_LastX = 0;
    m_LastY = 0;
    m_maskCurrentBanks = 0;
    m_iSurface = -1;
    m_iLastFootstepTick = m_pParentMenu->GetTickCount();
    m_bIsTouch = m_bPressedMouse = m_bPressed = false;
    m_key = EventKeyboard::KeyCode::KEY_NONE;

}


SceneFootsteps::~SceneFootsteps()
{
    auto dispatcher = Director::getInstance()->getEventDispatcher();
    dispatcher->removeEventListener(m_touchListener);
    dispatcher->removeEventListener(m_mouseListener);
}

void SceneFootsteps::onRelease()
{
    //m_labelPos = NULL;
    m_bPressedMouse = NULL;
    // Unregister the Car game object
    AK::SoundEngine::UnregisterGameObj(GAME_OBJECT_CAR);
    m_lastMenuIx = 2;
}

Scene* SceneFootsteps::createScene()
{
    // 'scene' is an autorelease object
    auto scene = Scene::create();
    // 'layer' is an autorelease object
    auto layer = SceneFootsteps::create();
    // add layer as a child to scene
    scene->addChild(layer);
    // return the scene
    return scene;
}

// on "init" you need to initialize your instance
bool SceneFootsteps::init()
{
    //////////////////////////////
    // 1. super init first
    if (!SceneBase::init())
    {
	return false;
    }

    cocos2d::Size windowSize = Director::getInstance()->getWinSize();
    float descriptionPosX = windowSize.width  * 0.50f;
    float descriptionPosY = windowSize.height * 0.90f;
    float selectButtonPosX = windowSize.width  * 0.15f;


    /////////////////////////////
    // 2. add a menu item with "X" image, which is clicked to quit the program
    //    you may modify it.
    {
	int iHalfWidth  = m_pParentMenu->GetWidth()	* 0.5;
	int iHalfHeight = m_pParentMenu->GetHeight()	* 0.5;
	m_LastX = m_x = iHalfWidth;
	m_LastY = m_y = iHalfHeight;

	cocos2d::Label * label = addLabel("Metal", 0, 0, FONT_SIZE_MENU, this);
	int iTextWidth = 40;//label->getWidth(); //dm.width;
	int iTextHeight = 40;//label->getHeight(); //dm.height;
	label->setPosition(cocos2d::Point(iHalfWidth - BUFFER_ZONE - iTextWidth, iHalfHeight - BUFFER_ZONE - iTextHeight));
	addLabel("Dirt",    iHalfWidth - BUFFER_ZONE - iTextWidth,  iHalfHeight + BUFFER_ZONE, FONT_SIZE_MENU, this);
	addLabel("Gravel",  iHalfWidth + BUFFER_ZONE,		    iHalfHeight - BUFFER_ZONE - iTextHeight, FONT_SIZE_MENU, this);
	addLabel("Wood",    iHalfWidth + BUFFER_ZONE,		    iHalfHeight + BUFFER_ZONE, FONT_SIZE_MENU, this);

	//
	m_sprite = CCSprite::create("human.png");
	m_sprite->setPosition(ccp(iHalfWidth, iHalfHeight));
	m_sprite->setScale(1.5f);
	this->addChild(m_sprite, 1);

	char strBuf[50];
	int iPosX = m_pParentMenu->GetWidth() * 0.4;
	int iPosY = m_pParentMenu->GetHeight() * 0.8;
	snprintf(strBuf, 50, "Weight is: %.2f", m_weight);

	// Draw the play position and subtitles
	//pMenu = addLabelEx(strBuf, iPosX, iPosY, FONT_SIZE_MENU, this);
    }

    // Mouse event
    m_mouseListener = EventListenerMouse::create();
    m_mouseListener->onMouseMove = CC_CALLBACK_1(SceneFootsteps::onMouseMove, this);
    m_mouseListener->onMouseDown = CC_CALLBACK_1(SceneFootsteps::onMouseDown, this);
    m_mouseListener->onMouseUp = CC_CALLBACK_1(SceneFootsteps::onMouseUp, this);
    _eventDispatcher->addEventListenerWithSceneGraphPriority(m_mouseListener, this);

    // Touch event
#if defined(AK_ANDROID) || defined(AK_IOS)
    m_touchListener = EventListenerTouchOneByOne::create();
    //m_touchListener->setSwallowTouches(true);
    m_touchListener->onTouchBegan = CC_CALLBACK_2(SceneFootsteps::onTouchBegan, this);
    m_touchListener->onTouchMoved = CC_CALLBACK_2(SceneFootsteps::onTouchMoved, this);
    m_touchListener->onTouchEnded = CC_CALLBACK_2(SceneFootsteps::onTouchEnded, this);
    //m_touchListener->onTouchCancelled = CC_CALLBACK_2(SceneFootsteps::onTouchCancelled, this);
    _eventDispatcher->addEventListenerWithSceneGraphPriority(m_touchListener, this);
#endif

    // Register the "Human" game object
    AK::SoundEngine::RegisterGameObj(GAME_OBJECT_HUMAN, "Human");

    // Load the sound bank
    ManageSurfaces(m_pParentMenu->GetWidth() / 2, m_pParentMenu->GetHeight() / 2, GAME_OBJECT_HUMAN);

    // Initialize the page
    m_bPlayingEngine = false;

    scheduleUpdate();

    return true;
}

void SceneFootsteps::menuCloseCallback(Ref* pSender)
{
    // Unregister the Car game object
    AK::SoundEngine::UnregisterGameObj(GAME_OBJECT_CAR);

    // Unload the soundbank
    AK::SoundEngine::UnloadBank("Car.bnk", NULL);

    auto director = Director::getInstance();
    director->replaceScene(SceneMain::createScene());
    this->removeAllChildren();
}

void SceneFootsteps::update(float dt)
{
    SceneBase::update(dt);


    if (m_bPressed) {
	//char strBuf[50];
	//snprintf(strBuf, 50, "<update> m_bPressed:%d m_key:%x \n", m_bPressed, m_key);
	//OutputDebugStringA(strBuf);

	switch (m_key) {
	case EventKeyboard::KeyCode::KEY_LEFT_ARROW:
	case EventKeyboard::KeyCode::KEY_RIGHT_ARROW:
	case EventKeyboard::KeyCode::KEY_UP_ARROW:
	case EventKeyboard::KeyCode::KEY_DOWN_ARROW:
	    onKeyPressed(m_key, NULL);
	    break;
	}
    }

    //UpdateGameObjPos();
}

void SceneFootsteps::onMouseDown(Event *event)
{
    EventMouse* e = (EventMouse*)event;
    if (e->getMouseButton() == EventMouse::MouseButton::BUTTON_LEFT) {
	bool bRet = false;
	//CCPoint pt = m_sprite->getPosition();
	CCPoint pt(e->getCursorX(), e->getCursorY());
	CCRect  rc = m_sprite->boundingBox();
	//CCRect  rect(Vec2(m_LastX, m_LastY), Size(5, 5));
	if (rc.containsPoint(pt)) {
	    //if (containsPoint(rc, pt)) {
	    bRet = true;
	    m_bPressedMouse = true;
	    UpdateGameObjPos(e->getCursorX(), e->getCursorY());
	}
#if defined(NDK_DEBUG) || defined(_DEBUG)
	char strBuf[50];
	snprintf(strBuf, 50, "<onMouseDown> %d %d (%g, %g)\n", bRet, e->getMouseButton(), e->getCursorX(), e->getCursorY());
	LOGAK(strBuf);
#endif
    }

}

void SceneFootsteps::onMouseMove(Event *event)
{
    EventMouse* e = (EventMouse*)event;
    if (m_bPressedMouse)
	UpdateGameObjPos(e->getCursorX(), e->getCursorY());

    //std::string str = "MousePosition X:";
    //str = str + tostr(e->getCursorX()) + " Y:" + tostr(e->getCursorY());
    //_labelPosition->setString(str.c_str());
    //    UpdateGameObjPos(e->getCursorX(), e->getCursorY());
}

void SceneFootsteps::onMouseUp(Event *event)
{
    m_bPressedMouse = false;

#if defined(NDK_DEBUG) || defined(_DEBUG)
    EventMouse* e = (EventMouse*)event;
    char strBuf[50];
    snprintf(strBuf, 50, "<onMouseUp> %d (%g, %g)\n", e->getMouseButton(), e->getCursorX(), e->getCursorY());
//    OutputDebugStringA(strBuf);
    LOGAK(strBuf);
#endif
}

bool SceneFootsteps::onTouchBegan(cocos2d::Touch *touch, cocos2d::Event *event)
{
    bool bRet = false;
    CCPoint pt = touch->getLocation();
    CCRect  rc = m_sprite->boundingBox();
    if (rc.containsPoint(pt)) {
	bRet = true;
	m_bIsTouch = true;
	UpdateGameObjPos(pt.x, pt.y);
    }

#if defined(NDK_DEBUG) || defined(_DEBUG)
    char strBuf[50];
    snprintf(strBuf, 50, "<onTouchBegan> %d (%g, %g)\n", bRet, pt.x, pt.y);
    LOGAK(strBuf);
#endif
    return true;
}

void SceneFootsteps::onTouchMoved(cocos2d::Touch *touch, cocos2d::Event *event)
{
    //EventTouch* e = (EventTouch*)event;
    if (m_bIsTouch)
	UpdateGameObjPos(touch->getLocation().x, touch->getLocation().y);
}

void SceneFootsteps::onTouchEnded(cocos2d::Touch *touch, cocos2d::Event *event)
{
    m_bIsTouch = false;
#if defined(NDK_DEBUG) || defined(_DEBUG)
    char strBuf[50];
    snprintf(strBuf, 50, "<onTouchEnded>  (%d, %d)\n",  (int)touch->getLocation().x, (int)touch->getLocation().y);
    LOGAK(strBuf);
#endif
}

void SceneFootsteps::onTouchCancelled(cocos2d::Touch *touch, cocos2d::Event *event)
{}

void SceneFootsteps::onKeyPressed(cocos2d::EventKeyboard::KeyCode keyCode, cocos2d::Event* unused_event)
{
#define INCREASE_DECREASE  5
    int x = m_LastX;
    int y = m_LastY;

    //int iPosX = m_pParentMenu->GetWidth() * 0.4;
    //int iPosY = m_pParentMenu->GetHeight() * 0.8;

    m_key = keyCode;

    switch (keyCode) {
    case EventKeyboard::KeyCode::KEY_LEFT_ARROW:
	x -= INCREASE_DECREASE;
	if (x < 0)  x = 0;
	m_bPressed = true;
	break;
    case EventKeyboard::KeyCode::KEY_RIGHT_ARROW:
	x += INCREASE_DECREASE;
//	if (x > m_pParentMenu->GetWidth())  x = m_pParentMenu->GetWidth();
	m_bPressed = true;
	break;
    case EventKeyboard::KeyCode::KEY_UP_ARROW:
	y += INCREASE_DECREASE;
//	if (y > m_pParentMenu->GetHeight())  y = m_pParentMenu->GetHeight();
	m_bPressed = true;
	break;
    case EventKeyboard::KeyCode::KEY_DOWN_ARROW:
	y -= INCREASE_DECREASE;
	if (y < 0)  y = 0;
	m_bPressed = true;
	break;
 //   case EventKeyboard::KeyCode::KEY_ESCAPE:
	//m_bPressed = true;
	//menuCloseCallback(NULL);
	//return;

    default:
	SceneBase::onKeyPressed(keyCode, unused_event);
	return;
    }
    UpdateGameObjPos(x, y);
}

void SceneFootsteps::onKeyReleased(cocos2d::EventKeyboard::KeyCode keyCode, cocos2d::Event* unused_event)
{
    m_bPressed = false;
    m_key = EventKeyboard::KeyCode::KEY_NONE;

    UpdateGameObjPos(m_LastX, m_LastY);
}


void SceneFootsteps::UpdateGameObjPos(float x, float y)
{
#if defined(NDK_DEBUG) || defined(_DEBUG)
    char strBuf[50];
    snprintf(strBuf, 50, "Pos=(%.2f : %.2f)\n", x, y);
//    LOGAK(strBuf);
#endif

    if (m_sprite) m_sprite->setPosition(ccp(x, y));

    //Check on which surface we are.  In this demo, the screen is divided in 4 surfaces.
    ManageSurfaces((int)x, (int)y, GAME_OBJECT_HUMAN);

    //Set the environment ratios for this game object.
    ManageEnvironement((int)x, (int)y, GAME_OBJECT_HUMAN);

    //Compute the speed RTPC
    float dx = x - m_LastX;
    float dy = y - m_LastY;
    float dist = sqrt((float)dx*dx + dy*dy);

    float speed = dist * DIST_TO_SPEED;
    AK::SoundEngine::SetRTPCValue(AK::GAME_PARAMETERS::FOOTSTEP_SPEED, speed, GAME_OBJECT_HUMAN);

    float period = WALK_PERIOD - speed;	//Just to simulate that when running, the steps are faster.  No funky maths here, just a fudge factor.

					//Post the Footstep event if appropriate (if we are moving!)
    if (dist < 0.1f && m_iLastFootstepTick != -1)
    {
	//It stopped.  Play one last footstep.  Make it lighter (half) as if the other foot just came to rest.
	AK::SoundEngine::SetRTPCValue(AK::GAME_PARAMETERS::FOOTSTEP_WEIGHT, m_weight / 2.0f, GAME_OBJECT_HUMAN);
	AK::SoundEngine::PostEvent(AK::EVENTS::PLAY_FOOTSTEPS, GAME_OBJECT_HUMAN);
	m_iLastFootstepTick = -1;
#if defined(NDK_DEBUG) || defined(_DEBUG)
	snprintf(strBuf, 50, "PostEvent1 Pos=(%.2f : %.2f) dist=%.2f\n", x, y, dist);
	//OutputDebugStringA(strBuf);
	LOGAK(strBuf);
#endif
    }
    else if (dist > 0.1f && m_pParentMenu->GetTickCount() - m_iLastFootstepTick > period)
    {
	//Reset the RTPC to its original value so it has the proper value when starting again.			
	AK::SoundEngine::SetRTPCValue(AK::GAME_PARAMETERS::FOOTSTEP_WEIGHT, m_weight, GAME_OBJECT_HUMAN);
	AK::SoundEngine::PostEvent(AK::EVENTS::PLAY_FOOTSTEPS, GAME_OBJECT_HUMAN);
	m_iLastFootstepTick = m_pParentMenu->GetTickCount();
#if defined(NDK_DEBUG) || defined(_DEBUG)
	snprintf(strBuf, 50, "PostEvent2 Pos=(%.2f : %.2f) dist=%.2f\n", x, y, dist);
	LOGAK(strBuf);
#endif
    }

    m_LastX = x;
    m_LastY = y;
    WWISE::update();
}

#if defined( _DEMOFOOTSTEPS_DYNAMIC_BANK_LOADING )
int SceneFootsteps::ComputeUsedBankMask(int x, int y)
{
    /*
    The screen is divided in 4 sections for the surfaces.
    There is a buffer section between each where the banks of the adjacent sections are loaded
    so the footsteps aren't delayed by bank loading.  So there is a total 9 possible areas to manage.
    LD	   RD
    Dirt | D+W | Wood
    ----------------- TD
    D+M  | All | W+G
    ----------------- BD
    Metal| M+G | Gravel

    LD = Left Division
    RD = Right Division
    TD = Top Division
    BD = Bottom Division
    */

    int iHalfWidth = m_pParentMenu->GetWidth() / 2;
    int iHalfHeight = m_pParentMenu->GetHeight() / 2;
    int iBufferZone = (int)BUFFER_ZONE * 2;

    int bLeftDiv = x > iHalfWidth - iBufferZone;
    int bRightDiv = x < iHalfWidth + iBufferZone;
    int bBottomDiv = y > iHalfHeight - iBufferZone;
    int bTopDiv = y < iHalfHeight + iBufferZone;

    int maskBanks = ((bRightDiv & bBottomDiv) << 0) |	//Is the Dirt bank needed
	((bLeftDiv & bBottomDiv) << 1) |	//Is the Wood bank needed
	((bRightDiv & bTopDiv) << 2) |		//Is the Metal bank needed
	((bLeftDiv & bTopDiv) << 3);		//Is the Gravel bank needed

    return maskBanks;
}
#endif // defined( _DEMOFOOTSTEPS_DYNAMIC_BANK_LOADING )

void SceneFootsteps::ManageSurfaces(int x, int y, int in_GameObject)
{
#if defined( _DEMOFOOTSTEPS_DYNAMIC_BANK_LOADING )

    int maskBanks = ComputeUsedBankMask(x, y);

    for (size_t i = 0; i < DEMOFOOTSTEPS_SURFACE_COUNT; i++)
    {
	AkBankID bankID; // Not used
	int iBit = 1 << i;
	if ((maskBanks & iBit) && !(m_maskCurrentBanks & iBit))
	{
	    //Load banks asynchronously to avoid blocking the game thread.
	    if (AK::SoundEngine::LoadBank(k_surfaces[i].strBankFile.c_str(), NULL, NULL, AK_INVALID_POOL_ID, bankID) != AK_Success)
		maskBanks &= ~iBit;	//This bank could not be loaded.
	}

	//Unload banks asynchronously to avoid blocking the game thread.
	if (!(maskBanks & iBit) && (m_maskCurrentBanks & iBit))
	{
	    if (AK::SoundEngine::UnloadBank(k_surfaces[i].strBankFile.c_str(), NULL, NULL, NULL) != AK_Success)
		maskBanks |= iBit;	//This bank is still loaded
	}
    }

    //Remember which banks we loaded.
    m_maskCurrentBanks = maskBanks;

#else  // defined( _DEMOFOOTSTEPS_DYNAMIC_BANK_LOADING )

    if (m_maskCurrentBanks == 0)
    {
	for (int i = 0; i < DEMOFOOTSTEPS_SURFACE_COUNT; i++)
	{
	    // Load banks synchronously to make sure they're all available right from the start
	    AkBankID bankID; // Not used
	    if (AK::SoundEngine::LoadBank(k_surfaces[i].strBankFile.c_str(), AK_INVALID_POOL_ID, bankID) == AK_Success)
		m_maskCurrentBanks |= 1 << i; // Remember which banks we loaded.
	}
    }

#endif // defined( _DEMOFOOTSTEPS_DYNAMIC_BANK_LOADING )

    //Find which surface we are actually walking on.
    int iHalfWidth = m_pParentMenu->GetWidth() / 2;
    int iHalfHeight = m_pParentMenu->GetHeight() / 2;
    int indexSurface = (x > iHalfWidth) | ((y > iHalfHeight) << 1);
    if (x > iHalfWidth) {
	indexSurface = 1;
	if (y < iHalfHeight)   indexSurface = 3;
    } else {
	indexSurface = 0;
	if (y < iHalfHeight)   indexSurface = 2;
    }
    if (indexSurface != m_iSurface)
    {
	AK::SoundEngine::SetSwitch(AK::SWITCHES::SURFACE::GROUP, k_surfaces[indexSurface].idSwitch, in_GameObject);
#if defined(NDK_DEBUG) || defined(_DEBUG)
	char strBuf[50];
	snprintf(strBuf, 50, "SetSwitchx H:W=(%d : %d) ix:ix2(%d:%d)\n", m_pParentMenu->GetWidth(), m_pParentMenu->GetHeight(), indexSurface, m_iSurface);
	LOGAK(strBuf);
#endif
	m_iSurface = indexSurface;
    }
}

void SceneFootsteps::ManageEnvironement(int x, int y, int)
{
	AkAuxSendValue aHangarEnv;
	aHangarEnv.auxBusID = AK::SoundEngine::GetIDFromString("Hangar_Env");
	aHangarEnv.fControlValue = 0.f;

	//There is a hangar in the middle of the screen with a transition zone around it where 
	//the walker is still outside but starts to hear the effects of the hangar.
	int iHalfWidth = m_pParentMenu->GetWidth() / 2;
	int iHalfHeight = m_pParentMenu->GetHeight() / 2;
	int iDiffX = abs(x - iHalfWidth);
	int iDiffY = abs(y - iHalfHeight);

	//Ramp the environment value in the transition zone.  If the object is outside this zone,
	//the value will be capped anyway.  The result of this ramp is <0 when outside
	//the hangar and >1 when totally inside.
	float fPercentOutsideX = AkMax((iDiffX - HANGAR_SIZE) / HANGAR_TRANSITION_ZONE, 0.0f);
	float fPercentOutsideY = AkMax((iDiffY - HANGAR_SIZE) / HANGAR_TRANSITION_ZONE, 0.0f);

	aHangarEnv.fControlValue = 1.0f - AkMax(fPercentOutsideX, fPercentOutsideY);
	aHangarEnv.fControlValue = AkMax(0.0f, aHangarEnv.fControlValue);
	aHangarEnv.listenerID = LISTENER_ID;

	AK::SoundEngine::SetGameObjectOutputBusVolume(GAME_OBJECT_HUMAN, LISTENER_ID, 1.0f - aHangarEnv.fControlValue / 2.0f);
	AK::SoundEngine::SetGameObjectAuxSendValues(GAME_OBJECT_HUMAN, &aHangarEnv, 1);
}

/*
void SceneFootsteps::Weight_ValueChanged(void* in_pSender, ControlEvent*)
{
    //NumericControl* sender = (NumericControl*)in_pSender;
    //AK::SoundEngine::SetRTPCValue(AK::GAME_PARAMETERS::FOOTSTEP_WEIGHT, (AkRtpcValue)sender->GetValue(), GAME_OBJECT_HUMAN);
}*/

